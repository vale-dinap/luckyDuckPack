// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "./lib/interfaces/ILDP.sol";
import "./lib/interfaces/IWETH.sol";
import "./WethUnwrapper.sol";

// TODO: incentives code
// TODO: other tokens integration?
// TODO: complete holderWIthdraw implementation
// TODO: consider replacing weth unwrapper with simple ERC20 distribution
// TODO: when the contract is completed double check contract description comment

/**
 * @dev Lucky Ducks Pack rewarder contract: this contract's address is the NFT
 * collection's creator fees receiver.
 *
 * When a token from the LDP collection is traded and creator fees are sent to this,
 * token holders are able to claim their share of revenues by calling {withdraw}.
 *
 * A small portion of the revenues (6.25%) is forwarded to the collection creator,
 * token holders earn the remaining 93.75% proportionally to the amount of tokens
 * they hold.
 *
 * Revenues are bound to tokens, not to holder addresses: in other words,
 * selling a token without claiming its revenues first will transfer the ability
 * to claim them to the buyer.
 *
 * Supported currencies are ETH and WETH by default. If creator fees are received
 * in other tokens, a separate set of functions (callable by anyone) allow
 * to manually distribute/withdraw them.
 *
 * This contract is fair, unstoppable, unpausable, mostly immutable: admin can only
 * amend the creator address, but has no way to access funds meant for token
 * holders nor change the contract's behaviour.
 */
contract LDPRewarder is Ownable, ReentrancyGuard{

    // Type defining revenues info
    struct Revenues{
        uint256 lifetimeEarnings; // Lifetime amount earned per NFT
        mapping(uint256=>uint256) lifetimeCollected; // NFT ID => amount
    }

    /*struct Incentive{
        uint256 amount;
        mapping(uint256=>uint256) collected; // NFT ID => amount
        uint16 distributionDays;
    }*/

    // Store ETH revenues data
    Revenues private _revenues;

    ///
    mapping(address => Revenues) private _revenuesErc20; // (token contract address => Revenues)
    ///

    // Creator address
    address payable private _creator;
    // Lucky Ducks Pack NFT contract
    ILDP public nft;
    // WETH token and WETH Unwrapper contracts
    IWETH private constant Weth = IWETH(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);
    WethUnwrapper private immutable wethUnwrapper;

    /**
     * @dev Failsafe: set admin address as default beneficiary of creator
     * earnings.
     * Initialize the WETH unwrapper contract.
     */
    constructor(){
        _creator = payable(msg.sender);
        wethUnwrapper = new WethUnwrapper(address(Weth));
    }

    /**
     * @notice Link the token contract instance to the nft contract address.
     * Can be set only once and becomes immutable afterwards.
     */
    function setNftAddress(address nftAddr) external onlyOwner{
        require(address(nft)==address(0), "Overriding denied");
        nft = ILDP(nftAddr);
    }

    /**
     * @notice Admin function to amend the creator address.
     */
    function setCreatorAddress(address newAddress) external onlyOwner{
        require(newAddress!=address(0));
        _creator = payable(newAddress);
    }

    /**
     * @dev Handles the received fees as follows:
     * -store holders revenues (93.75%) in the smart-contract;
     * -forward creator revenues (6.25%) to creator's address;
     * -unwrap any WETH previously sent to this smart-contract and
     * handle these likewise.
     */
    receive() external payable{
        uint256 holdersCut;
        uint256 creatorsCut;
        (creatorsCut, holdersCut) = _calculateCuts(msg.value);
        _revenues.lifetimeEarnings+=(holdersCut/10000);
        _creatorPayout(creatorsCut);
        _unwrapWethIfAny();
    }

    /**
     * @notice Allows LDP holders to withdraw the revenues generated by
     * their tokens.
     */
    function withdraw() external nonReentrant{
        _holderWithdraw(msg.sender);
    }

    // function to show token earnings and user earnings, TODO: implement
    //function reveiceERC20token TODO: implement this

    // INTERNAL LOGICS - Incoming transactions

    /**
     * @dev Send funds to creator address.
     */
    function _creatorPayout(uint256 amount) private{
        (bool success, ) = _creator.call{value: amount}("");
        require(success, "Payout error");
    }

    /**
     * @dev Calculate holders and creator revenues from the given amount.
     */
    function _calculateCuts(uint256 amount)
        pure
        private
        returns(uint256 creatorsCut, uint256 holdersCut)
    {
        creatorsCut=amount/16; // 6.25% to creator
        holdersCut=amount-creatorsCut; // 93.75% to holders
    }

    /**
     * @dev If this smart-contract holds any WETH, unwrap it.
     * By doing so, the receive function is also called and the
     * unwrapped ETH are added to the revenues. This is a workaround
     * as normally the automatic revenues distribution cannot occur
     * if the creator fees are paid out in WETH.
     */
    function _unwrapWethIfAny() private{
        uint256 bal = Weth.balanceOf(address(this));
        if(bal>0) {
            Weth.transfer(address(wethUnwrapper), bal);
            wethUnwrapper.unwrap(bal);
            wethUnwrapper.withdraw();
        }
    }

    // INTERNAL LOGICS - Withdraws

    /**
     * @dev Calculate holders and creator revenues from the given amount.
     */
    function _holderWithdraw(address account) private{
        uint256 amount;
        for(uint256 i; i<nft.balanceOf(account); ++i){
            amount += _processWithdrawalData(0); // TODO: replace "0" with to tokenOfOwnerByIndex
        }
        payable(msg.sender).transfer(amount);
    }

    /**
     * @dev Called when revenues are claimed: returns the amount of revenues
     * claimable by the specified token ID and records that these revenues
     * have now been collected.
     */
    function _processWithdrawalData(uint256 tokenId) private returns(uint256 accruedRevenues){
        accruedRevenues = _revenues.lifetimeEarnings-_revenues.lifetimeCollected[tokenId];
        _revenues.lifetimeCollected[tokenId]=_revenues.lifetimeEarnings;
    }

}