// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "./lib/interfaces/ILDP.sol";
import "./lib/interfaces/IWETH.sol";
import "./WethUnwrapper.sol";

// TODO: incentives code
// TODO: other tokens integration?
// TODO: complete holderWIthdraw implementation

contract LDPRewarder is Ownable, ReentrancyGuard{

    // Type defining revenues info
    struct Revenues{
        uint256 lifetimeEarnings; // Lifetime amount earned per NFT
        mapping(uint256=>uint256) lifetimeCollected; // NFT ID => amount
    }

    /*struct Incentive{
        uint256 amount;
        mapping(uint256=>uint256) collected; // NFT ID => amount
        uint16 distributionDays;
    }*/

    // Store ETH revenues data
    Revenues private _revenues;

    ///
    address[] private _revenueTokens;
    mapping(address=>bool) private _isRevenueToken;
    mapping(address => Revenues) private _revenuesErc20; // (token contract address => Revenues)
    ///

    // Creator
    address payable private _creator;
    // Instance of the LDP token contract
    ILDP public nft;
    // Instances of the WETH (token) and WETH Unwrapper contracts
    IWETH public constant Weth = IWETH(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);
    WethUnwrapper private immutable wethUnwrapper;

    constructor(){
        _creator = payable(msg.sender);
        wethUnwrapper = new WethUnwrapper(address(Weth));
    }

    /**
     * @notice Link the token contract instance to the nft contract address.
     * Can be set only once, then it becomes immutable.
     */
    function setNftAddress(address nftAddr) external onlyOwner{
        require(address(nft)==address(0), "Overriding denied");
        nft = ILDP(nftAddr);
    }

    /**
     * @notice Admin function to amend the creator address.
     */
    function setCreatorAddress(address newAddress) external onlyOwner{
        require(newAddress!=address(0));
        _creator = payable(newAddress);
    }

    /**
     * @dev Handles the received fees as follows:
     * -store holders revenues (93.75%) in the smart-contract;
     * -forward creator revenues (6.25%) to creator's address;
     * -unwrap any WETH previously sent to this smart-contract and
     * handle these likewise.
     */
    receive() external payable{
        uint256 holdersCut;
        uint256 creatorsCut;
        (creatorsCut, holdersCut) = _calculateCuts(msg.value);
        _revenues.lifetimeEarnings+=(holdersCut/10000);
        _creatorPayout(creatorsCut);
        _unwrapWethIfAny();
    }

    /**
     * @notice Allows LDP holders to withdraw the revenues generated by
     * their tokens.
     */
    function withdraw() external nonReentrant{
        _holderWithdraw(msg.sender);
    }

    //function reveiceERC20token TODO: implement this

    // INTERNAL LOGICS - Incoming transactions

    /**
     * @dev Send funds to creator address.
     */
    function _creatorPayout(uint256 amount) private{
        (bool success, ) = _creator.call{value: amount}("");
        require(success, "Payout error");
    }

    /**
     * @dev Calculate holders and creator revenues from the given amount.
     */
    function _calculateCuts(uint256 amount)
        pure
        private
        returns(uint256 creatorsCut, uint256 holdersCut)
    {
        creatorsCut=amount/16; // 6.25% to creator
        holdersCut=amount-creatorsCut; // 93.75% to holders
    }

    /**
     * @dev If this smart-contract holds any WETH, unwrap it.
     * By doing so, the receive function is also called and the
     * unwrapped ETH are added to the revenues. This is a workaround
     * as normally the automatic revenues distribution cannot occur
     * if the creator fees are paid out in WETH.
     */
    function _unwrapWethIfAny() private{
        uint256 bal = Weth.balanceOf(address(this));
        if(bal>0) {
            Weth.transfer(address(wethUnwrapper), bal);
            wethUnwrapper.unwrap(bal);
            wethUnwrapper.withdraw();
        }
    }

    // INTERNAL LOGICS - Withdraws

    /**
     * @dev Calculate holders and creator revenues from the given amount.
     */
    function _holderWithdraw(address account) private{
        uint256 amount;
        for(uint256 i; i<nft.balanceOf(account); ++i){
            amount += _processWithdrawalData(0); // TODO: replace "0" with to tokenOfOwnerByIndex
        }
        payable(msg.sender).transfer(amount);
    }

    /**
     * @dev Called when revenues are claimed: returns the amount of revenues
     * claimable by the specified token ID and records that these revenues
     * have now been collected.
     */
    function _processWithdrawalData(uint256 tokenId) private returns(uint256 accruedRevenues){
        accruedRevenues = _revenues.lifetimeEarnings-_revenues.lifetimeCollected[tokenId];
        _revenues.lifetimeCollected[tokenId]=_revenues.lifetimeEarnings;
    }

}